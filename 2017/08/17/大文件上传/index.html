<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Tongby"><title>大文件上传 · Nostalgia</title><meta name="description" content="大文件断点续传(上传篇)吐槽阶段（可以跳过）由于之前按照公司的需求要做一个 （简单!!!） 云盘类的功能，既然是云盘基础的就是上传下载，于是基于AFN做了一个展示加进度、不可暂停、不可续传的简单传输列表，不知道老大哪天奇思妙想要求加了一个可以断点续传可以断点下载的功能，作为一个有原则的程序猿，只能点"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Nostalgia</a></h3><div class="description"><p>ios,iOS,AFN,OC,TBYSKY</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>大文件上传</a></h3></div><div class="post-content"><h1 id="大文件断点续传-上传篇"><a href="#大文件断点续传-上传篇" class="headerlink" title="大文件断点续传(上传篇)"></a>大文件断点续传(上传篇)</h1><h2 id="吐槽阶段（可以跳过）"><a href="#吐槽阶段（可以跳过）" class="headerlink" title="吐槽阶段（可以跳过）"></a>吐槽阶段（可以跳过）</h2><p>由于之前按照公司的需求要做一个 （简单!!!） 云盘类的功能，既然是云盘基础的就是上传下载，于是基于AFN做了一个展示加进度、不可暂停、不可续传的简单传输列表，不知道老大哪天奇思妙想要求加了一个可以断点续传可以断点下载的功能，作为一个有原则的程序猿，只能点头答应嗯能做,于是开始google…</p>
<h2 id="google结果"><a href="#google结果" class="headerlink" title="google结果"></a>google结果</h2><p>不清楚是我搜的方式不对还是说当时没有人做这个功能我是没有搜到可以复制粘贴的代码（妄想做一个代码的搬运工）最后庆幸的是断点续传没找到，不过找到了一份还不错的断点下载的demo，扯远了本篇只说断点上传。</p>
<h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>前提由于我先做的下载是基于原生的<code>NSURLSessionDownloadTask</code>封装的下载管理类，所有首先想到的是同样基于<code>NSURLSessionUploadTask</code>做一个一样的断点续传管理类，中间第一步就是公司的后台的<code>HTTPS</code>中的<code>header</code>中<code>cookie</code>一定要带着id还有就是在上传文件体的时候需要转换的文件格式，这是本人在网上借鉴到的代码看的第一眼就有点晕晕感觉（本人才疏学浅）</p>
<img src="/2017/08/17/大文件上传/AFN-upload-body.png" title="This is an example image">
<p>但是还坚持这接着写，文件体的问题解决了，又遇到<code>https</code>证书的问题由于开发阶段没有域名都是ip地址直接访问，导致不安全无法访问，改info.plist忽略认证并不起作用，最后是通过这个代理解决的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//主要就是处理HTTPS请求的</span><br><span class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLProtectionSpace *protectionSpace = challenge.protectionSpace;</span><br><span class="line">    if ([protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">        SecTrustRef serverTrust = protectionSpace.serverTrust;</span><br><span class="line">        completionHandler(NSURLSessionAuthChallengeUseCredential, [NSURLCredential credentialForTrust:serverTrust]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当写到这里的时候都是在尝试阶段发现并不是我想要的样子复杂程度暂且不提，就是以后遇到的坑还不清楚有多少维护成本太高了，于是开始研究<code>AFN</code>由于<code>AFN</code>是在吧底层的上传分装了起来随意一些包体、请求头、参数等给了我们很方便的方式去携带。</p>
<h2 id="开始AFN断点上传"><a href="#开始AFN断点上传" class="headerlink" title="开始AFN断点上传"></a>开始AFN断点上传</h2><p><code>AFN</code>就不介绍了，直接动手：</p>
<ol>
<li>既然分装一个上传管理类首先要有一个对应的上传模型，我定义的模型（当初为了方便和项目略微耦合后期需要修改)：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 相册文件的唯一标识</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * burstIdentifier;</span><br><span class="line">/**</span><br><span class="line"> 上传唯一标识</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * fileUpLoadID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 父文件夹id</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * parentFolder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 文件MD5</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * fileMd5;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 文件的地址</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * filePath;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 文件的大小</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSInteger totalSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 已上传大小</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSInteger completeSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 任务状态 0 等待上传 、1正在上传 、2 暂停 、3 失败、4 成功</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * taskStatus;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 文件名</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * fileName;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 文件类型 </span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString * fileType;</span><br></pre></td></tr></table></figure>
<p>创建一个单例模型的管理类，体统一个对外的上传方法，至于是等待还是直接上传由内部进行管理，每次上传文件开始前先存一份在数据库中，一方面是为了列表显示，另一方面是断点续传的文件地址和进度：       </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//判断数据库中存不存在</span><br><span class="line">if ([[HXUploadFMDBManager share] uploadLoadFileIsExistingWithFileID:model.burstIdentifier]) &#123;</span><br><span class="line">        </span><br><span class="line">    NSArray * arr = [[HXUploadFMDBManager share] getUpLoadFileWithBurstIdentifier:model.burstIdentifier];</span><br><span class="line">        </span><br><span class="line">    TB_Upload * up = arr[0];</span><br><span class="line">        </span><br><span class="line">    model = [[HXMainModel alloc] initWithTB_Upload:up];</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">//向上传字典中添加上传模型</span><br><span class="line">[self.uploadIngDic setValue:model forKey:model.burstIdentifier];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;md5&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">__block NSDictionary * paramentDic;</span><br><span class="line"></span><br><span class="line">//获取上传参数</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    if (model.parament) &#123;</span><br><span class="line">        </span><br><span class="line">        paramentDic = model.parament;</span><br><span class="line">        </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSData * data = [NSData dataWithContentsOfFile:[NSString getAbsolutePathFromRelativePath:model.filePath]];</span><br><span class="line">        if (!model.fileMD5) &#123;</span><br><span class="line">            model.fileMD5 = [NSString getMD5WithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        model.filesize = data.length;</span><br><span class="line">        </span><br><span class="line">        if (model.parentfolder) &#123;</span><br><span class="line">            </span><br><span class="line">            paramentDic = @&#123;@&quot;md5&quot; :model.fileMD5,</span><br><span class="line">                            @&quot;size&quot; : [NSString stringWithFormat:@&quot;%lu&quot;,model.filesize],</span><br><span class="line">                            @&quot;name&quot; : model.titleStr,</span><br><span class="line">                            @&quot;folderid&quot;:model.parentfolder&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面为什么把当前的上传模型装到字典中后面会解释，首先说一下由于上传需要携带文件MD5的作为参数，而文件转对应的MD5会很慢所以放到一个队列当中，当完成后插入数据库中如果数据库中存在当前任务即更新状态，不存在插入一条新的记录。</p>
<p>然后需要判断是否可以上传文件由于可能会有需要多任务并行上传或者单任务上传的情况，尝试过<code>NSOperation</code>和<code>NSOperationQueue</code>管理首先不提他不会自动进行下一个任务同时设置当前任务取消继续，并没有API写的那么方便 <!--可能是我并不是很会用-->于是自己用数组替代的任务队列手动管理，所以每次上传之前进行判断是否可以上传如果任务数超过可以上传的最大值把当前上传模型放到等待数组中，如果没超过直接上传 这里用了一个<code>@synchronized</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isCanUploadWithModel:(HXMainModel *)model&#123;</span><br><span class="line">    </span><br><span class="line">    @synchronized (self)&#123;</span><br><span class="line">        </span><br><span class="line">        if (self.downloadingModels.count &gt;= _maxCount) &#123;</span><br><span class="line">            </span><br><span class="line">            if ([self.waitingDownloadModels indexOfObject:model] == NSNotFound)&#123;</span><br><span class="line">                </span><br><span class="line">                [self.waitingDownloadModels addObject:model];</span><br><span class="line">                </span><br><span class="line">                model.fileState = FileUploadStatePrepare;</span><br><span class="line">            &#125;</span><br><span class="line">            //文件状态改变的回调</span><br><span class="line">            [self changeStateWithModel:model];</span><br><span class="line">            </span><br><span class="line">            return NO;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            if ([self.waitingDownloadModels indexOfObject:model] != NSNotFound) &#123;</span><br><span class="line">                </span><br><span class="line">                [self.waitingDownloadModels removeObject:model];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">            if ([self.downloadingModels indexOfObject:model] == NSNotFound)&#123;</span><br><span class="line">                </span><br><span class="line">                [self.downloadingModels addObject:model];</span><br><span class="line">                </span><br><span class="line">                model.fileState = FileUploadStateSending;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            //文件状态改变时候抛出去的回调</span><br><span class="line">            [self changeStateWithModel:model];</span><br><span class="line">            </span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接上传的文件需要首先去服务器要一下当前文件已经上传的大小，然后从服务器返回的<code>size</code>开始上传，还有一步也是最重要的一步由于是断点续传对我们来说就是要应该把文件一部分一部分的上传上传（按道理应该是并行上传由于后台的一些不可抗力只能同步上传），这一步就是把上传的文件分块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//文件的总大小</span><br><span class="line">NSUInteger totalLength = model.filesize - size;</span><br><span class="line">//_minBlock 每块的带下单位是byte</span><br><span class="line">NSUInteger count = totalLength/_minBlock +(totalLength % _minBlock ? 1 : 0);</span><br><span class="line">//创建一个任务组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">//创建一个串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">__block NSInteger result = 0;</span><br><span class="line"></span><br><span class="line">[model.uploadTask cancel];</span><br><span class="line"></span><br><span class="line">for (int i =0; i &lt; count ; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger startSize = 0;</span><br><span class="line">    __block NSInteger endSize;</span><br><span class="line">    </span><br><span class="line">    startSize =  size + _minBlock * i;</span><br><span class="line">    </span><br><span class="line">    endSize = startSize + _minBlock;</span><br><span class="line">    </span><br><span class="line">    //如果大于文件总大小既等于文件总大小</span><br><span class="line">    </span><br><span class="line">    if (endSize &gt;= model.filesize) &#123;</span><br><span class="line">        </span><br><span class="line">        endSize = model.filesize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        __block  BOOL isStop = NO;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        HXMainModel * mainModel = weakSelf.uploadIngDic[model.burstIdentifier];</span><br><span class="line">        </span><br><span class="line">        if (mainModel) &#123;</span><br><span class="line">            </span><br><span class="line">            isStop = mainModel.isStop;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (result == 0 &amp;&amp; !isStop) &#123;</span><br><span class="line">            //调用上传方法 返回结果是上传成功/失败</span><br><span class="line">            result  =  [weakSelf uploadFileWithStartSize:startSize endSize:endSize model:model parament:parament];</span><br><span class="line">            </span><br><span class="line">            [model.uploadTask cancel];</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            </span><br><span class="line">            LCLog(@&quot;出错了/或者暂停了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重点说一下上传方法，上传主要调用的就是<code>AFN</code>的上传方法，这里有断点续传所以要设置一下上传的请求头里的<code>Content-Range</code>这个自行百度一下就可以了,然后这里的需要用到信号等待当这个块完成后再去返回成功/失败 这里<code>AFN</code>上传文件写内存的问题，大文件会把整个文件写入内存当完成上传后再释放，虽然分块了但是我发现他依然会当整个文件上传成功后才会自动释放所有块的大小加了一个自动释放池让他可以更快的释放掉，顺带提一下这里读取文件用的是<code>NSFileHandle</code> 所以才需要解决内存占用的问题 尝试过<code>NSInputStream</code>但是没找到可以读一段的方法（如有知道望指导）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 上传当前文件块  返回 0 成功 返回 1 失败</span><br><span class="line"></span><br><span class="line"> @param startSize 开始位置</span><br><span class="line"> @param endSize 结束位置</span><br><span class="line"> @param model 模型</span><br><span class="line"> @param parament 参数</span><br><span class="line"> */</span><br><span class="line">- (NSInteger)uploadFileWithStartSize:(NSInteger)startSize endSize:(NSInteger)endSize model:(HXMainModel *)model parament:(NSDictionary *)parament&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger tag;</span><br><span class="line">    </span><br><span class="line">    WS(weakSelf)</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">     dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        </span><br><span class="line">    //设置请求头</span><br><span class="line">    [[HXAFNManager share] setRangeWithAllSize:model.filesize startSize:startSize endSize:endSize];</span><br><span class="line">        </span><br><span class="line">        HXMainModel * mainModel = weakSelf.uploadIngDic[model.burstIdentifier];</span><br><span class="line">        </span><br><span class="line">        if (mainModel) &#123;</span><br><span class="line">        </span><br><span class="line">            mainModel.uploadTask =  [[HXAFNManager share] uploadLargeFileWithUrlstr:@&quot;url&quot; paramenters:parament ConstructingBodyBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123;</span><br><span class="line">                </span><br><span class="line">                @autoreleasepool &#123;</span><br><span class="line">                    </span><br><span class="line">                    model.filePath = [NSString getAbsolutePathFromRelativePath:model.filePath];</span><br><span class="line">                    </span><br><span class="line">                    NSFileHandle *readHandle = [NSFileHandle fileHandleForReadingAtPath:model.filePath];</span><br><span class="line">                    long long offset = startSize;</span><br><span class="line">                    </span><br><span class="line">                    [readHandle seekToFileOffset:offset];</span><br><span class="line">                    </span><br><span class="line">                    _data =  [readHandle readDataOfLength:(endSize - startSize)];</span><br><span class="line">                    </span><br><span class="line">                    [formData appendPartWithFileData:_data name:@&quot;files&quot; fileName:model.titleStr mimeType:@&quot;application/octet-stream&quot;];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; progress:^(NSProgress *uploadProgress) &#123;</span><br><span class="line">                </span><br><span class="line">                if (uploadProgress.completedUnitCount ==  uploadProgress.totalUnitCount) &#123;</span><br><span class="line">                    </span><br><span class="line">                    model.alreadyUpload += (NSInteger)uploadProgress.totalUnitCount;</span><br><span class="line">                    </span><br><span class="line">                    [weakSelf changeUploadProgress:model blockProgress:0];</span><br><span class="line">                    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    </span><br><span class="line">                    [weakSelf changeUploadProgress:model blockProgress:uploadProgress.completedUnitCount];</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;Success:^(NSDictionary *object) &#123;</span><br><span class="line">                </span><br><span class="line">                tag = 0;</span><br><span class="line">                </span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">                </span><br><span class="line">            &#125; Failure:^(NSString *error) &#123;</span><br><span class="line">                </span><br><span class="line">                tag = 1;</span><br><span class="line">                </span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">                </span><br><span class="line">                LCLog(@&quot;%@&quot;,error);</span><br><span class="line">                </span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    //等待信号</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有一块上传失败就当这个任务上传失败后续的任务会自动跳出组。<br>当整个“组”完成进行下一个任务的上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">       </span><br><span class="line">       //循环结束或者暂停从上传任务数组中清除</span><br><span class="line">       @synchronized (self)&#123;</span><br><span class="line">           </span><br><span class="line">           [weakSelf.downloadingModels removeObject:model];</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if (result != 0) &#123;</span><br><span class="line">           </span><br><span class="line">           model.fileState = FileUploadStateFailure;</span><br><span class="line">           </span><br><span class="line">       &#125;else&#123;</span><br><span class="line"></span><br><span class="line">           model.fileState = FileUploadStateSuccessful;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if (model.isStop) &#123;</span><br><span class="line">           </span><br><span class="line">           model.fileState = FileUploadStateStop;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [weakSelf changeStateWithModel:model];</span><br><span class="line">       </span><br><span class="line">       [weakSelf willUploadNextTaskWithModel:model];</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>最后解释一下为什么把当前上传模型存到字典中一是为了可以当暂停或者取消任务是直接找到当前模型所携带的<code>NSURLSessionDataTask</code>，由于当前上传的数组中也存在为什么再存一份这就是为了更快的找到对应的模型<br>，这个是整体的上传模型第一次写博客（明知道废话连篇 却不知道怎么精简）如果写的哪里有问题望指导。</p>
<h3 id="微信-：tby970477784"><a href="#微信-：tby970477784" class="headerlink" title="微信 ：tby970477784"></a>微信 ：tby970477784</h3></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-17</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/08/17/大文件上传/,Nostalgia,大文件上传,;"></a></div></div><div class="pagination"><ul class="clearfix"></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>